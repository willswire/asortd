<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>ASORTD | Algorithm Sorting Display</title>
	<!-- JavaScript needed for this webpage -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
	<script type="text/javascript" src="scripts/displayList.js"></script>
	<script src="https://kit.fontawesome.com/9c3b18b2e3.js"></script>
	<!-- Style Resources -->
	<link rel="stylesheet" href="resources/style.css" />
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
		integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous" />
</head>

<body>
	<!-- Div that contains the main display -->
	<div class="container">
		<!-- Row that contains the two column structure -->
		<div class="row">
			<!-- Column that contains the sorting display and controls -->
			<div class="col-md">
				<!-- The main sorting display -->
				<div id="main" class="shadows">
					<!-- The container that holds all the items being sorted -->
					<h1>ASORTD</h1>
					<div id="sorting_container"></div>
				</div>
				<!-- Row that contains the controls, each control is in a column -->
				<div class="row" id="control_panel">
					<!-- Column that contains the previous button -->
					<div class="col" style="padding-left: 0">
						<button class="controls shadows" id="prev_button">
							<i class="fas fa-backward"></i>
						</button>
					</div>
					<!-- Column that contains the start button -->
					<div class="col">
						<button class="controls shadows" id="sort_button">
							START
						</button>
					</div>
					<!-- Column that contains the next button -->
					<div class="col" style="padding-right: 0">
						<button class="controls shadows" id="next_button">
							<i class="fas fa-forward"></i>
						</button>
					</div>
				</div>
				<!-- Row that contains the speed controls-->
				<div class="row" id="control_panel">
					<div class="card col shadows" id="slider">
						<span class="label label-primary" style="text-align:center">SPEED</span>
						<input type="range" class="custom-range" id="slider_range" id="customRange2" />
					</div>
				</div>
				<div class="row" id="control_panel">
					<div class="dropdown">
						<button class="dropdown-toggle controls" type="button" id="dropdownMenuButton"
							data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
							Select Sorting Algorithm
						</button>
						<div class="dropdown-menu" aria-labelledby="dropdownMenuButton" id="dd-menu">
							<a class="dropdown-item" href="#">Bubble Sort</a>
							<a class="dropdown-item" href="#">Shell Sort</a>
							<a class="dropdown-item" href="#">Quick Sort</a>
							<a class="dropdown-item" href="#">Selection Sort</a>
						</div>
					</div>
				</div>
			</div>
			<!-- Column that contains the info about each sort, and the dropdown to select sorts -->
			<div class="col-md">
				<div class="row" style="margin: 0;">
					<div id="asortd-info" class="shadows info" style="display: initial;">
						<h2>ASORTD</h2>
						<p>
							ASORTD (Algoirthm Sorting Display) helps visualize a few of the various sorting algorithms
							that
							are most often taught in the computer science curriculum.
						</p>
					</div>
					<div id="bubble-info" class="shadows info">
						<h2>Bubble Sort</h2>
						<p>
							Bubble sort, sometimes referred to as sinking
							sort, is a simple sorting algorithm that
							repeatedly steps through the list, compares
							adjacent elements and swaps them if they are in
							the wrong order. The pass through the list is
							repeated until the list is sorted. The
							algorithm, which is a comparison sort, is named
							for the way smaller or larger elements "bubble"
							to the top of the list.
							<ul>
								<li><strong>Worst Case:</strong> O(n<sup>2</sup>)</li>
								<li><strong>Best Case:</strong> O(n)</li>
							</ul>
						</p>
					</div>
					<div id="shell-info" class="shadows info">
						<h2>Shell Sort</h2>
						<p>
							Shellsort, also known as Shell sort or Shell's method,
							is an in-place comparison sort. It can be seen as either a
							generalization of bubble sort or insertion sort. The method
							starts by sorting pairs of elements far apart from each other,
							then progressively reducing the gap between elements to be compared.
							Starting with far apart elements, it can move some out-of-place elements
							into position faster than a simple nearest neighbor exchange.
							<ul>
								<li><strong>Worst Case:</strong> O(n<sup>2</sup>)</li>
								<li><strong>Best Case:</strong> O(n log(n))</li>
							</ul>
						</p>
					</div>
					<div id="quick-info" class="shadows info">
						<h2>Quick Sort</h2>
						<p>
							Quicksort (sometimes called partition-exchange sort) is an efficient sorting algorithm,
							serving as a systematic method for placing the elements of a random access file or an array
							in order. Developed by British computer scientist Tony Hoare in 1959 and published in
							1961, it is still a commonly used algorithm for sorting. When implemented well, it can be
							about two or three times faster than its main competitors, merge sort and
							heapsort.

							Quicksort is a comparison sort, meaning that it can sort items of any type for which a
							"less-than" relation (formally, a total order) is defined. Efficient implementations of
							Quicksort are not a stable sort, meaning that the relative order of equal sort items is not
							preserved. Quicksort can operate in-place on an array, requiring small additional amounts of
							memory to perform the sorting. It is very similar to selection sort, except that it does not
							always choose worst-case partition.
						</p>
					</div>
					<div id="selection-info" class="shadows info">
						<h2>Selection Sort</h2>
						<p>
							In computer science, selection sort is a sorting algorithm, specifically an in-place
							comparison sort. It has O(n^2) time complexity, making it inefficient on large lists, and
							generally performs worse than the similar insertion sort. Selection sort is noted for its
							simplicity, and it has performance advantages over more complicated algorithms in certain
							situations, particularly where auxiliary memory is limited.

							The algorithm divides the input list into two parts: the sublist of items already sorted,
							which is built up from left to right at the front (left) of the list, and the sublist of
							items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist
							is empty and the unsorted sublist is the entire input list. The algorithm proceeds by
							finding the smallest (or largest, depending on sorting order) element in the unsorted
							sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted
							order), and moving the sublist boundaries one element to the right.
						</p>
					</div>
				</div>
				<div class="row" style="margin: 3% 0 3% 0;">
					<div id="bubble-psuedo" class="shadows info" style="width: 100%">
						<h2>Pseudo Code</h2>
						<pre id="exampleCode">
begin BubbleSort(list)

	for all elements of list
		if list[i] > list[i+1]
			swap(list[i], list[i+1])
		end if
	end for
	
	return list
	
end BubbleSort</pre>
					</div>
					<div id="shell-psuedo" class="shadows info" style="width: 100%">
						<h2>Pseudo Code</h2>
						<pre id="exampleCode">
calculate gap size ($gap)
while $gap is greater than 0

	for each element of the list, that is $gap apart
		Extract the current item
		Locate the position to insert
		Insert the item to the position
	end for

	calculate gap size ($gap)

end while
</pre>
					</div>
					<div id="quick-psuedo" class="shadows info" style="width: 100%">
						<h2>Pseudo Code</h2>
						<pre id="exampleCode">
algorithm quicksort(A, lo, hi) is
if lo < hi then
	p := partition(A, lo, hi)
	quicksort(A, lo, p)
	quicksort(A, p + 1, hi)

algorithm partition(A, lo, hi) is
	pivot := A[lo + (hi - lo) / 2]
	i := lo - 1
	j := hi + 1
	loop forever
		do
			i := i + 1
		while A[i] < pivot
		do
			j := j - 1
		while A[j] > pivot
		if i >= j then
			return j
		swap A[i] with A[j]</pre>
					</div>
					<div id="selection-psuedo" class="shadows info" style="width: 100%">
						<h2>Pseudo Code</h2>
						<pre id="exampleCode">
int i,j;
int aLength;

for (i = 0; i < aLength-1; i++)
{
int jMin = i;
for (j = i+1; j < aLength; j++)
{
	if (a[j] < a[jMin])
	{
		jMin = j;
	}
}
if (jMin != i) 
{
	swap(a[i], a[jMin]);
}
}</pre>
					</div>
				</div>
			</div>
		</div>
	</div>
</body>

</html>